%_______________________________________________________________________
%
% Compute condition-wise variability with the LS-S model
%_______________________________________________________________________
%
% Input
%
% job | batch job generated by tbx_cfg_variability (struct)
%
%_______________________________________________________________________
%
% Output
%
% output | batch job with result file paths (struct)
%
% 190108 | JQK fixed lines 117 ff deletion of onsets and durations
% 190117 | had to fix tempdir for tardis line 202
%_______________________________________________________________________
%
% This file is part of the Variability Toolbox for SPM
% Published by the Lifespan Neural Dynamics Group
% Provided under the GNU General Public License
% See LICENSE for terms and conditions

function output = event_var(job)

  cfg = shared_config;
  logger = shared_logger.getLogger();

  %%
  %% sanitize function parameters
  %%
  if isempty(job)
    error('No job defined.');
  end

  if iscell(job.metric)
    metric = job.metric;
  else
    metric = {job.metric};
  end

  %%
  %% read model specification
  %%
  model_file = char(job.modelmat);
  if exist(model_file,'file')
    model_job = load(model_file);
  else
    msg = sprintf('Unable to find model: %s ', model_file);
    error(msg)
  end
  matlabbatch = model_job.matlabbatch;
  fmri_spec = matlabbatch{1}.spm.stats.fmri_spec;
  sess = fmri_spec.sess;

  if ~isempty(job.resultprefix)
    result_prefix = [job.resultprefix '_'];
  else
    result_prefix = '';
  end

  %%
  %% TODO: change also job.testing in block_var and decide how to handle parameters from job vs. cfg structure
  %%
    
  if isfield(cfg,'testing') && cfg.testing
    istesting = true;
  else
    istesting = false;
  end

  if isfield(cfg,'dryrun') && cfg.dryrun
    isdryrun = true;
  else
    isdryrun = false;
  end
  
  if istesting
    num_sess = 1;
  else
    num_sess = numel(sess);
  end

  if istesting
    num_cond = 1;
  elseif isfield(job,'numcond') && job.numcond
    num_cond = job.numcond;
  else
    num_cond = numel(sess(1).cond);
  end

  num_model_cond = zeros(num_cond,1);

  %%
  %% create a separate model for each trial (LS-S)
  %%
  for s = 1:num_sess
    condition = sess(s).cond;

    for c = 1:num_cond
      
      if istesting
        condition(c).onset = condition(c).onset(1:3);
        condition(c).duration = condition(c).duration(1);
      end
            
      onset = condition(c).onset(:);
      
      %%
      %% Events that are very close to the end of a time series result
      %% in a truncated HRF in the design matrix which can result in
      %% insanely huge beta values which then would result in very large 
      %% condition-wise variances. To avoid this we remove all onsets
      %% that are less than 20 seconds away from the end of the current
      %% session/time series. Furthermore require the time series to be 
      %% at least twice as long as the HRF.
      
      num_scans = numel(sess(s).scans); % e.g. 139 scans
      tr = fmri_spec.timing.RT; % e.g. 2s
      ts_dur = num_scans * tr; % e.g. 278s
      hrf_dur = 20; % in seconds

      if strcmp(fmri_spec.timing.units, 'scans')
          onsetInSec = condition(c).onset.*fmri_spec.timing.RT;
          if ts_dur > 2*hrf_dur
            onset = onset(onsetInSec<ts_dur-hrf_dur);
            duration = condition(c).duration(onsetInSec<ts_dur-hrf_dur);
          end
      else % original code for the case that units are seconds, not scans
          if ts_dur > 2*hrf_dur
            onset = onset(onset<ts_dur-hrf_dur);
          end
          duration = condition(c).duration(:);
          if numel(duration) == 1
            duration = duration(1) * ones(numel(onset), 1);
          end
      end

      for m = 1:numel(onset)

        %%
        %% interest trials of current condition
        %%
        model.interest.onset = onset(m);
        model.interest.duration = duration(m);

        %%
        %% non-interest trials of current condition
        %%
        model.nuisance.onset = [onset(1:m-1); onset(m+1:end)];
        model.nuisance.duration = [duration(1:m-1); duration(m+1:end)];

        %%
        %% to avoid "This concatenation operation includes an empty
        %% array with an incorrect number of columns" warning
        %%
        if isempty(model.nuisance.onset)
          model.nuisance.onset = [];
          model.nuisance.duration = [];
        end

        %%
        %% non-interest trials of other conditions
        %%
        nuisance_cond = [1:c-1, c+1:num_cond]';
        for ni = 1:numel(nuisance_cond)% ori, puts all nuisance events in 1 single regressor
          nc = nuisance_cond(ni);
          nuis_onset = condition(nc).onset(:);
          nuis_duration = condition(nc).duration(:);
          if numel(nuis_duration) == 1
            nuis_duration = nuis_duration(1) * ones(numel(nuis_onset), 1);
          end
          model.nuisance.onset = [model.nuisance.onset; nuis_onset];
          model.nuisance.duration = [model.nuisance.duration; nuis_duration];
        end

        lss.sess(s).cond(c).model(m) = model;
        num_model_cond(c) = num_model_cond(c) + 1;

      end % onset
    end % cond
  end % sess  

  batch_beta = matlabbatch;
  batch_beta{1}.spm.stats.fmri_spec = rmfield(fmri_spec,'sess');
  base_dir = char(job.resultdir);
  job_result_files = [];


  %%
  %% TODO: do we want to use job.tempdir, or cfg.tempdir or none of those?
  %% TODO: this should probably be merged into the serial processing loop
  %%       below since it is irrevelant for the parallel processing loop
  %%
%   if ismac
%     tmp_dir = tempname;
%   else % avoid using local temporary space on grid nodes since it is very limited
%     tmp_dir = job.tempdir;
%   end
   
    tmp_dir = [base_dir, 'temp/'];


  if not(exist(tmp_dir,'dir'))
    mkdir(tmp_dir);
  end

  %%
  %% apply mask if specified
  %%
    mask_file = char(fmri_spec.mask);
  subj_hdr = spm_vol([sess(1).scans{1} ',1']);
  subj_dim = subj_hdr.dim;

	if not(isempty(mask_file))
		mask_hdr = spm_vol(mask_file);
		if not(spm_check_orientations([subj_hdr, mask_hdr]))
			error('Scans differ in orientation, dimension or voxel size.');
		end
		mask_img = spm_read_vols(mask_hdr);
		coord = find(mask_img);
	else
    coord = 1:prod(subj_dim);
	end

  %%
  %% compute beta images for trials
  %%

  if cfg.gui
    %% enable workaround to prevent design window from popping up
    spm_get_defaults('cmdline', 1);

    %% workaround for pixel shifts with default renderer
	  progress_window = spm_figure('GetWin','Interactive');
	  set(progress_window, 'Renderer','OpenGL');
  end

  if cfg.parallel
    shared_parpool('open')
    fprintf('\n')
  elseif logger.consoleLevel <= logger.INFO
    fprintf('\n')
    disp('Parallel mode disabled')
    fprintf('\n')
  end
  
  %%
  %% condition
  %%
  for c = 1:num_cond

    beta_img = [];
    label_action = 'Computing ';
    cond_name = condition(c).name;
    
    if cfg.gui
      cond_name = strrep(cond_name,'_','\_');  
      label_text = [label_action cond_name];
  	  label = [cfg.format label_text];
  	  spm_progress_bar('Init', 100, label, '', 't');
    else
      label_text = [label_action condition(c).name];
  	  fprintf('%+*s', cfg.pad, label_text)
      prog_bar = shared_progbar(num_model_cond(c));
    end

    cur_model = 0;
    %beta_img = zeros(num_model_cond(c), size(coord,1)); 
    beta_img = zeros(num_model_cond(c), size(coord,2)); % bug fix Marija; changed back to original version
    
    %%
    %% session
    %%
    for s = 1:num_sess

      if istesting
        % num_model = 3;
        num_model = numel(lss.sess(s).cond(c).model);
      else
        num_model = numel(lss.sess(s).cond(c).model);
      end
  
      %%
      %% template for beta series
      %% condition 1: interest
      %% condition 2: nuisance
      %%
      sess_beta = rmfield(sess(s),'cond');
      sess_beta.cond(1:2) = struct('name','','onset',[],'duration',[],'pmod',struct([]),'tmod',0);

      if cfg.parallel

        %%
        %% TODO: show fine-grained progbar with percentage from shared_parprog if running in CLI mode?
        %%
        parfor m = 1:num_model
        %for m = 1:num_model
        
          disp(['Running model ... ', num2str(m)]);

          pad_model = numel(num2str(num_model));
          pad_sess = numel(num2str(num_sess));
          tmp_dir = fullfile(base_dir,'spm',[result_prefix, condition(c).name, ...
                    '_' sprintf('%0*i',pad_sess,s) '-' sprintf('%0*i',pad_model,m)]);

          if not(exist(tmp_dir,'dir'))
            mkdir(tmp_dir);
          end
          
          model = lss.sess(s).cond(c).model(m);
          beta_img(cur_model + m,:) = event_model(model, sess_beta, batch_beta, coord, tmp_dir, isdryrun);
          
          %%
          %% remove temporary data
          %%
          if not(cfg.keeptemp)
            delete([tmp_dir '/*'])
            rmdir(tmp_dir)
          end
          
        end

        %%
        %% remove temporary data
        %%
        if not(cfg.keeptemp)
          rmdir(fullfile(base_dir,'spm'))
        end

        cur_model = cur_model + num_model;

        if cfg.gui %% workers don't have access to the display so update the gui progress bar only every session
          progress = round(100 * cur_model / num_model_cond(c));
          spm_progress_bar('Set', progress);
        else
          %%
          %% TODO: when running in CLI mode check if running in Console of Matlab GUI because it
          %%       doesn't support certain shell cursor movement commands, so progbar has glitches
          %%       maybe check the patched progbar version in MSE grid scripts
          %%
          prog_bar.update(cur_model);
        end
        
      else % serial processing of models

        for m = 1:num_model
          disp(['Running model ... ', num2str(m)]);

          pad_model = numel(num2str(num_model));
          pad_sess = numel(num2str(num_sess));
          tmp_dir = fullfile(base_dir,'spm',[result_prefix, condition(c).name, ...
                    '_' sprintf('%0*i',pad_sess,s) '-' sprintf('%0*i',pad_model,m)]);

          if not(exist(tmp_dir,'dir'))
            mkdir(tmp_dir);
          end
            
          cur_model = cur_model + 1; % counting across sessions
          model = lss.sess(s).cond(c).model(m);
          beta_img(cur_model,:) = event_model(model, sess_beta, batch_beta, coord, tmp_dir, isdryrun);
          %% remove temporary data
          if not(cfg.keeptemp)
            delete([tmp_dir '/*'])
            rmdir(tmp_dir,'s')
          end
          if cfg.gui
            progress = round(100 * cur_model / num_model_cond(c));
            spm_progress_bar('Set', progress);
          else
            prog_bar.update(cur_model);
          end
        end
        %% remove temporary data
        %%
        if not(cfg.keeptemp)
          rmdir(fullfile(base_dir,'spm'),'s')
        end
      end % cfg.parallel?

    end % sess

    if not(cfg.gui)
      prog_bar.stop;
    end

    input_file = sess(1).scans{1};

    %%
    %% compute and save variability images for the chosen metrics
    %%
    %% format: result/sd/condition/sub123_condition_sd.nii
    %%
    for m = 1:numel(metric)
      
      if numel(metric) > 1
        result_dir = fullfile(base_dir, metric{m}, condition(c).name);
      else
        result_dir = base_dir;
      end

      if ~exist(result_dir, 'dir')
        mkdir(result_dir)
      end

      result_voxel = shared_var(beta_img, metric{m});
      result_image = zeros(subj_dim);
      result_image(coord) = result_voxel;
      result_file = fullfile(result_dir, [result_prefix condition(c).name '_' metric{m} '.nii']);
      shared_save_nifti(input_file, result_file, result_image);
      job_result_files{end+1} = result_file;

    end % metric

    %%
    %% save the raw beta series to enable later inspection
    %%
    job.savebeta = true;
    if isfield(job,'savebeta') && job.savebeta
      
      if numel(metric) > 1
        result_dir = fullfile(base_dir, 'beta_series', condition(c).name);
      else
        result_dir = fullfile(base_dir, 'beta_series');
      end

      if ~exist(result_dir, 'dir')
        mkdir(result_dir)
      end

      num_beta = size(beta_img,1);
      result_image = zeros([num_beta subj_dim]);
      for b = 1:num_beta
        result_image(b,coord) = beta_img(b,:);
      end
      result_file = fullfile(result_dir, [result_prefix condition(c).name '_beta_series.nii']);
      shared_save_nifti(input_file, result_file, result_image);

    end % savebeta

  end % condition

  fprintf('Result files are in %s\n\n', result_dir)

  if cfg.gui
    %% disable workaround to prevent design window from popping up
    spm_get_defaults('cmdline', 0);
  end

  if cfg.parallel
    shared_parpool('close')
  end

	output.result_files = job_result_files;

end % event_var_lss

function foobar

end